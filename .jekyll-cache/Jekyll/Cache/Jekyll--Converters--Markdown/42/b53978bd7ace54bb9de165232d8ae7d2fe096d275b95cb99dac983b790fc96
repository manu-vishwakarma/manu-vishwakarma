I"Äk<p class="text-justify">BERT is a language model published by google. This model can be used for multiple NLP tasks such as NER, Classification, Question and Answer, Sequence Prediction, etc. BERT makes use of Transformer, an attention mechanism that learns contextual relations between words (or sub-words) in a text. The transformer includes two mechanisms, an encoder that read the text input and a decoder that produces a prediction for the task <a href="/manish_vishwakarma/Transformer">(link)</a>. But BERT is a special form of transformer where it uses only the encoder stack of the transformer, not the decoder stack thatâ€™s why it is named as Bidirectional Encoder Representations from Transformers (BERT).</p>

<p class="text-justify">One of the biggest problems with the deep neural network-based models is that they require a hell lot of data for training, otherwise they are very prone to overfitting. In NLP there are many tasks and most of the task-specific datasets contain only a few thousand human-labeled data for training.</p>
<p class="text-justify">In the domain of computer vision, people have already solved this problem by developing the pre-trained model on imageNet dataset like vgg16, vgg 19, resNet, etc. These models can be fined tuned on your dataset and you can use their learned feature representation for your task-specific problem.</p>
<p class="text-justify">Similarly in NLP to close this gap Google came up with the idea of BERT, in which the model is pre-trained on a large unannotated text dataset collected from the web. We can easily fine-tune this pre-trained model with the smaller dataset for tasks like NER, Q&amp;A, sequence prediction, classification, etc.</p>
<p class="text-justify">Google claims with BERT model anyone can train their state-of-the-art models in 30 minutes on a single Cloud TPU, or in a few hours using a single GPU. <a href="https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html">(Open Sourcing BERT: State-of-the-Art Pre-training for Natural Language Processing)</a></p>

<h1 id="what-is-different-in-bert-compared-to-other-models">What is different in BERT compared to other models?</h1>

<p>BERT is the only first deeply trained bidirectional model and also it is an unsupervised language model. Unlike the other models such as ELMO, ULMFit, GPT, etc. BERT is pre-trained only on plain text corpus collected from Wikipedia data.</p>
<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b1.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.1<a href="https://arxiv.org/pdf/1810.04805.pdf"> Differences in pre-training model architectures.</a></p>

<p class="text-justify">As you can see in Fig.1 BERT uses a bidirectional Transformer and OpenAI GPT uses a left-to-right Transformer. ELMo uses the concatenation of independently trained left-to-right and right to left LSTMs to generate features. Also, BERT and OpenAI GPT use a fine-tuning approach, while ELMo is a feature-based approach.</p>

<h1 id="why-bert-approach-is-better">Why BERT approach is better?</h1>
<p class="text-justify">In NLP based tasks the representations we use can be either context-free or contextual. Models like word2vec, glove, fasttext, etc. are context-free models in which every word will have the same representation irrespective of the sentence context. For example, the word â€œappleâ€ will have the same context-free representation in â€œapple products are greatâ€ and in  â€œEating an apple a day will make you healthyâ€. But the contextual models will generate a different representation for the word â€œappleâ€ in both sentences. The contextual model understands the word generally from the words that are before them, in BERT it uses Bi-Directional Encoder which also includes the words that are after the targeted word so that in the end we can generate a better contextual representation for the given word.</p>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b2.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.2 <a href="https://www.semanticscholar.org/paper/Conditional-BERT-Contextual-Augmentation-Wu-Lv/188024469a2443f262b3cbb5c5d4a96851949d68/figure/0">Bert Architecture</a></p>
<!-- <p align="center"></p> -->

<h1 id="bert-io">Bert I/O</h1>
<p class="text-justify">Bert model uses three types of input - token id, sentence id (In which sentence token belongs) and the transformer positional embedding. Along with this, Bert uses some special tokens in its input and output format during its pre-training and fine-tuning task.</p>
<ul class="text-justify">
  <li>[CLS]: The first token of every sequence. A classification token which is normally used with a softmax layer for classification tasks. For anything else, it can be safely ignored.</li>
</ul>
<ul class="text-justify">
  <li>[SEP]: A sequence delimiter token which was used at pre-training for sequence-pair tasks (i.e. Next sentence prediction). Must be used when sequence pair tasks are required. When a single sequence is used it is just appended at the end.</li>
</ul>
<ul class="text-justify">
  <li>[MASK]: Token used for masked words. It is used during pre-training. Bert uses MLM (Masked Langauge Model) for training the model and NSP (Next Sentence Prediction).</li>
</ul>
<ul class="text-justify">
  <li>[##ing]: These are special tokens, used to represent words like playing. (play + ing). To handle out of vocabulary words.</li>
</ul>

<h1 id="bert-input-format">BERT Input Format</h1>
<p>The input embeddings are the sum of the token embeddings, the segmentation embeddings, and the position embeddings.</p>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b3.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.3 <a href="https://arxiv.org/pdf/1810.04805.pdf">BERT input representation</a></p>
<p><br /></p>
<ul>
  <li>Token Embeddings: Vocabulary IDs for each of the tokens.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b4.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.4<a href="https://medium.com/@_init_/why-bert-has-3-embedding-layers-and-their-implementation-details-9c261108e28a"> Token Embedding</a></p>

<p><br /></p>
<ul class="text-justify">
  <li>Segment Embeddings: Numeric class to distinguish sentences A and B. We will later understand why we are taking two sentences in the pre-training section of BERT.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b5.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.5 <a href="https://medium.com/@_init_/why-bert-has-3-embedding-layers-and-their-implementation-details-9c261108e28a">Segment Embedding</a></p>

<p><br /></p>
<ul class="text-justify">
  <li>Positional embeddings: Indicate the position of each word in the sequence. This is important in Bert for the transformer to understand the difference between the same word at different position e.g. sentence â€”&gt; I think I liked recent Marvel movie. In this, we are using the same â€œIâ€ but they are in a different position and they can have different contextual meanings, so we can specify this part using positional embeddings.</li>
</ul>

<h1 id="importance-of-positional-embeddings">Importance of positional Embeddings</h1>
<ul>
  <li>The architecture of an RNN allows it to implicitly encode sequential information using its hidden state. For example, in Fig.6 RNN that outputs a representation for each word for the sentence â€œI think therefore I amâ€.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b6.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.6 RNN Representation</p>

<ul class="text-justify">
  <li>In the above sentence, the output representation of both the word â€œIâ€ will be different because of RNN architecture. In RNN for a given sentence, sequences are fed to the network at different time stamps with changed hidden states. For example, the initial word â€œIâ€ hidden state is just initialized as compared to the later word â€œIâ€. For the 2nd â€œIâ€ the hidden state will be passed through the previous words â€œI think, thereforeâ€. which will result in the different output representations. So due to how RNN works the words at different positions will have different output representations.</li>
</ul>
<ul class="text-justify">
  <li>But in transformer, input sequences or words are all fed to the self-attention layer at the same timestamp not one by one. So in the sentence â€œI think therefore I amâ€  for both words â€œIâ€, the representation will be the same. So to avoid this case in the input layer along with tokens embedding we also add positional embedding.</li>
</ul>
<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b7.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.7</p>

<ul class="text-justify">
  <li>So in Fig.7 for the word â€œIâ€ we are keeping the RPR (Relative Position Representation) value of 4, so based on these other words will get the value of 5,6,7 &amp; 8. The number on the arrow represents the RPR value of the respective tokens and these values will be used for computing the attention. So when we are trying to compute the attention between the word â€œIâ€ and the word â€œthereforeâ€, it will 6th RPR value, because they are 2 words away from each other.</li>
</ul>
<ul>
  <li>The next diagram shows the representation of the 2nd â€œIâ€ in the same sequence:</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b8.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.8</p>

<ul class="text-justify">
  <li>For the second â€œIâ€ we will use the same RPR value of 4 to compute output representation. But the RPR value for the words which are to its left and right will change as per the Fig.8. Now when we try to compute the attention between the word â€œthereforeâ€ and â€œIâ€ it will be different because itâ€™s one word away from the word â€œIâ€. So in short what we are trying to preserve using RPR is the relative position between the words and also we have to make it consistent. <a href="https://medium.com/@_init_/how-self-attention-with-relative-position-representations-works-28173b8c245a">Read How Self-Attention with Relative Position Representations works for detail information.</a></li>
</ul>

<ul class="text-justify">
  <li>Note this is just the simpler explanation for how positional encoding works in the transformer, in BERT paper they use below equation to maintain the relative information between the tokens. <a href="https://kazemnejad.com/blog/transformer_architecture_positional_encoding/">(The Positional Encoding blog).</a></li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b9.png" alt="transormer_attention_mechanism" /></p>
<p align="center"> <a href="https://arxiv.org/pdf/1706.03762.pdf">Fig.9 Position Encoding Formula</a></p>

<ul>
  <li>In the paper they are using a pre-train positional embedding, which will be added with the all words based on their position in the sequence.</li>
</ul>

<h1 id="wordpiece-embedding">WordPiece embedding</h1>

<p class="text-justify">In NLP models, we have input as the sentence â€œI went to new york last week.â€  i.e. sequence of words which we tokenize in the form of a list of words [â€œiâ€, â€œwentâ€, â€œtoâ€, â€œnewâ€, â€œyorkâ€, â€œlastâ€, â€œweekâ€, â€œ.â€]. Previous models like word2vec, glove, etc. use tokenizer which tokenizes sentences in the form of a list of words, but all these models have some problems with their way of working. Suppose the model learns the word â€œoldâ€, â€œolderâ€, â€œlowerâ€ &amp; â€œlowestâ€. Then a word letâ€™s say â€œoldestâ€ occurs then the model will consider it as an out of vocabulary word, it wonâ€™t be able to extract the relationship for the word â€œoldestâ€ from the learned words or sub-words. Now in this type of scenario using sub-tokens will solve our problem and BPE uses the sub-token method for tokenization. Letâ€™s understand how BPE works.</p>

<h4 id="-wordpiece-bpe-algorithm-working-"><a href="https://leimao.github.io/blog/Byte-Pair-Encoding/"> WordPiece/ BPE Algorithm working </a></h4>
<ul class="text-justify">
  <li>In order to handle out of vocabulary words, BPE uses word piece to handle or to understand the tokens.</li>
  <li>We count the frequency of each word shown in the corpus. For each word, we append a special stop token â€œ&lt;/w&gt;â€ at the end of the word. We then split the word into characters. Initially, the tokens of the word are all of its characters plus the additional â€œ&lt;/w&gt;â€ token. For example, the tokens for the word â€œlowâ€ are [â€œlâ€, â€œoâ€, â€œwâ€, â€œ&lt;/w&gt;â€] in order. So after counting all the words in the dataset, we will get a vocabulary for the tokenized word with its corresponding counts.</li>
</ul>

<ul class="text-justify">
  <li>Suppose in our dataset, initially, we have only 4 words as you can see in Fig.10 i.e. low, lowest, newer, wider and if a word letâ€™s say â€˜Lowerâ€™ appeared then it will be considered as OOV (out of vocabulary). To handle this type of scenario in BPE we generally follow four stages of merging to handle unknown tokens.</li>
</ul>
<ul class="text-justify">
  <li>In this stage we break down words into its characters, so as you can see in Fig.10 we have our initial vocabulary with the count. We have two words â€œnewerâ€ and â€œwiderâ€ which end with â€œrâ€ so our new symbol will become r + &lt;/w&gt; (&lt;/w&gt; represents end symbol) and then we also have â€œerâ€ in the same two words so we can have a symbol er&lt;/w&gt;. Then similarly we have â€œLâ€ and â€œOâ€ characters in words â€œlowâ€ and â€œlowestâ€. So we can have symbol â€œLOâ€ and then we have the word â€œWâ€ added to our word â€œLOâ€ by which we will have symbol â€œlowâ€ added into our vocabulary.</li>
</ul>

<p align="center"><b>Vocabulary: {'r&lt;/w&gt;': 9, 'er&lt;/w&gt;': 9, 'l': 7, 'lo': 7, 'low': 7, . . . . . . . . . . }
</b></p>

<ul>
  <li>Now a new word â€œlowerâ€ which is not there in the vocabulary can be handled with the above created new vocabulary using word pieces. So to handle it we will break down the word â€œlowerâ€ into low + er (low and er both words are there in the vocabulary) and we can represent the word â€œlowerâ€ low_er&lt;/w&gt; as shown in the Fig.10</li>
</ul>
<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b10.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.10 BPE Working</p>

<h4 id="encoding-and-decoding-of-the-words">Encoding and Decoding of the words</h4>
<ul class="text-justify">
  <li>Decoding is extremely simple, you just have to concatenate all the tokens together and you will get the original whole word. For example, if the encoded sequence is [â€œthe&lt;/w&gt;â€, â€œhighâ€, â€œest&lt;/w&gt;â€, â€œmounâ€, â€œtain&lt;/w&gt;â€], we immediately know the decoded sequence â€œthe&lt;/w&gt; highest&lt;/w&gt; mountain&lt;/w&gt;â€.</li>
</ul>

<ul class="text-justify">
  <li>To decode a tokenized list of words into a sentence, we just have to concatenate words which are not ending with the symbol â€œ&lt;/w&gt; with the word with â€œ&lt;/w&gt;â€ symbol. For example, if the encoded sequence is [â€œthe&lt;/w&gt;â€, â€œhighâ€, â€œest&lt;/w&gt;â€, â€œmounâ€, â€œtain&lt;/w&gt;â€], we just have to concatenate â€œhighâ€ with â€œest&lt;/w&gt; to make â€œhighestâ€ word and then the word  â€œmounâ€ with the word â€œtain&lt;/w&gt;â€ to make â€œmountainâ€. Eventually, in the end, we will get the decoded sentence as â€  â€œthe&lt;/w&gt; highest&lt;/w&gt; mountain&lt;/w&gt;â€.</li>
</ul>

<!-- - How about encoding then? Given word sequence, say, [â€œthe</w>â€, â€œhighest</w>â€, â€œmountain</w>â€]. We have all the tokens listed in the order from long tokens to short tokens. For each word, we iterate through all the tokens and check if each token is a substring of the word. if so, then that token is one of the tokens in the word. In this example, we assume the tokens are [â€œerrrr</w>â€, â€œtain</w>â€, â€œmounâ€, â€œest</w>â€, â€œhighâ€, â€œthe</w>â€, â€œa</w>â€]. We iterate from the longest token â€œerrrr</w>â€ to the shortest token â€œa</w>â€ trying to replace the substring in each of the words to tokens. Eventually, we will iterate through all the tokens and all the substrings will be replaced with tokens. If there is still substring left but all the tokens were iterated, we replace the remaining subwords to tokens like for unknown tokens. In this example, we get tokenization ["the</w>"] for word "the</w>", tokenization ["high", "est</w>"] for the word "highest</w>", and tokenization ["moun", "tain</w>"] for "mountain</w>".
{: .text-justify} -->

<ul class="text-justify">
  <li>To encode the previous sentence â€œthe highest mountainâ€ we will tokenize them in the list of words with &lt;/w&gt; as the end of word symbol after each word like [â€œthe&lt;/w&gt;â€, â€œhighest&lt;/w&gt;â€, â€œmountain&lt;/w&gt;â€]. So to split the words into sub-tokens we will go through our token list for each word one by one and if the token is present then we will split the word into sub-tokens. For example, we have a list of tokens [â€œerrrr&lt;/w&gt;â€, â€œtain&lt;/w&gt;â€, â€œmounâ€, â€œhighâ€, â€œest&lt;/w&gt;â€, â€œthe&lt;/w&gt;â€, â€œa&lt;/w&gt;â€]. Now for each word we will iterate through the token list from the longest token to shortest token. If we found any substring after we have completed the iteration then we will split the word into the sub-tokens. For the word â€œmountainâ€, we have tokens [â€œmounâ€, â€œtain&lt;/w&gt;â€]. For the word â€œtheâ€ we have just â€œthe&lt;/w&gt;â€ and for the word â€œhighestâ€ we will have [â€œhighâ€, â€œest&lt;/w&gt;â€].</li>
</ul>

<!-- - Encoding is computationally very expensive. In practice, we could pre-tokenize all the words and save how a word should be tokenized in a dictionary. If we see an unknown word that does not exist in the dictionary, we apply the above encoding method to tokenize the word and add the tokenization of the new word to the dictionary for future reference.
{: .text-justify} -->

<ul class="text-justify">
  <li>As you can see, the encoding process is computationally very expensive. For each word, we have to search for the list of tokens in the token list. So in actual practice, we can pre-compute our tokenize sentence list in a dictionary and use this dictionary for encoding any sentence.</li>
</ul>

<p><b>NOTE: BPE algorithm used in WordPiece is slightly different from the original BPE.</b></p>

<h1 id="bert-pre-training">BERT Pre-Training</h1>
<h4 id="bert-model-is-pre-trained-using-the-following-two-methods">Bert Model is Pre-Trained using the following two methods</h4>
<ul>
  <li>Masked LM (MLM):
    <ul class="text-justify">
      <li>Assuming the unlabeled sentence is â€œmy dog is hairyâ€, and during the random masking procedure. We chose the 4th token (which corresponds to hairy):
        <ul>
          <li>80% of the time: Replace the word with the[MASK]token, 
    e.g. my dog is hairy â€”â€“&gt; my dog is [MASK].</li>
          <li>10% of the time: Replace the word with a random word,
    e.g. my dog is hairy  â€”â€“&gt; my dog is apple.</li>
          <li>10% of the time: Keep the word unchanged,
  e.g. my dog is hairy  â€”â€”&gt; my dog is hairy. The purpose of this is to bias the representation towards the actual observed word.</li>
        </ul>
      </li>
      <li>Since we all know how much prone DL models are to overfitting and if we do not generalize the relationship between the words it will just try to memorize everything. Thatâ€™s why masking is used with all these three different variations.</li>
    </ul>

    <ul class="text-justify">
      <li>The advantage of this procedure is that the Transformer encoder does not know which words it will be asked to predict or which have been replaced by random words, so it is forced to keep a distributional contextual representation of every input token. Additionally, because random replacement only occurs for 1.5% of all tokens(i.e., 10% of 15%), this does not seem to harm the modelâ€™s language understanding capability.</li>
    </ul>
  </li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b11.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.10 <a href="https://arxiv.org/pdf/1810.04805.pdf">Masking Results</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- In the table, MASK means that we replace the target token with the [MASK] symbol for MLM; SAME means that we keep the target token as it is; RND means that we replace the target token with another random token. The numbers in the left part of the table represent the probabilities of the specific strategies used during MLM pre-training (BERT uses 80%, 10%,10%).
</code></pre></div></div>

<p>NOTE: Read Appendix - A for more details on the importance of masked tokens and also read â€œAblation for Different Masking Proceduresâ€ in Bertâ€™s published paper for more details on the masking strategies and their results. <a href="https://arxiv.org/pdf/1706.03762.pdf">(link)</a></p>

<ul>
  <li>Next Sentence prediction (NSP):
    <ul class="text-justify">
      <li>
        <p>Input =&gt; [CLS] the man went to [MASK] store [SEP]he bought a gallon [MASK] milk [SEP]   Label=IsNext
Input =&gt; [CLS] the man [MASK] to the store [SEP]penguin [MASK] are flight ##less birds [SEP]  Label=NotNext</p>
      </li>
      <li>
        <p>In order to understand the relationship between the sentences, BERT is pre-trained on text corpus where it had to predict whether the given sentence is the next sentence or not. Many tasks in NLP such as Q&amp;A and NLI requires the understanding of the relationship not only between the words but also between the sentences as well. To tackle this type of problems in BERT, when choosing the sentences A and B for each pre-training example, 50% of the time B is the actual next sentence that follows A (labeled as IsNext), and 50% of the time it is a random sentence from the corpus (labeled as NotNext).</p>
      </li>
    </ul>
  </li>
</ul>

<h1 id="applications">Applications</h1>
<p>We can fine-tune BERT model on a smaller dataset and can use it for various NLP tasks based on their architecture:</p>

<ul>
  <li>Classification.</li>
  <li>Name Entity Recognizer (NER).</li>
  <li>Question and Answer (Q&amp;A).</li>
  <li>Feature-Extraction (Word Embedding).</li>
</ul>

<h3 id="classification">Classification</h3>
<p class="text-justify">We can fine-tune BERT model for classification by taking the [CLS] tokenâ€™s representation from the last output layer and we can compute the class probability with a softmax layer after it.</p>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b12.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.11 Bert for classification</p>

<h3 id="name-entity-recognition-ner">Name Entity Recognition (NER)</h3>
<ul class="text-justify">
  <li>In NER task we need to assign a tag to each word of the input sequence. It is equivalent to a classification task where the final output representation of the transformer is fed to the classification layer to get a prediction for every token. Because of WordPiece tokenizer, we split words into sub-words so we predict the classification probabilities only for the first token of a word.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b13.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.11 Bert for NER</p>

<h3 id="question-and-answer-qa">Question and Answer (Q&amp;A)</h3>
<ul class="text-justify">
  <li>Question answering is a prediction task. Given a question and a context paragraph, the model predicts a start and an end token from the paragraph that most likely answers the question.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b14.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.12 Bert for Q&amp;A</p>

<ul class="text-justify">
  <li>Just like sentence pair tasks, the question becomes the first sentence and paragraph the second sentence in the input sequence. There are only two new parameters learned during fine-tuning a â€œstartâ€ vector and an â€œendâ€ vector with a size equal to the hidden shape size. The same applies to the end token.</li>
</ul>

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b15.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.13 Bert for Q&amp;A</p>

<h3 id="feature-extraction-word-embeddings">Feature-Extraction (Word Embeddings)</h3>
<ul class="text-justify">
  <li>We can use BERT for feature-extraction as well and use other models on the extracted feature. <!-- on our models --> But just taking the last layers output representation of each word wonâ€™t give good results, to get better results we need to combine the output of certain layers. The BERT authors recommend not to use directly the [CLS] token embedding to get the representation of the whole sentence, it works well for the classification task only. The authors tested this by feeding different vector combinations from the different layers as an input to a BILSTM model which was used on an NER task and they computed the F1 score for the evaluation.</li>
</ul>

<ul class="text-justify">
  <li>So the concatenation of the last 4 layers on the NER task along with some other task gave the best results. But, it is recommended to test different combinations for a different types of problems.</li>
</ul>

<!-- - So the best result was observed on the concatenation of the last 4 layers on the NER task and also for some other tasks as well, but it is recommended to test different combinations for a different types of problems.
{: .text-justify} -->

<p style="text-align: center; "><img src="/manu-vishwakarma/assets/img/b16.png" alt="transormer_attention_mechanism" /></p>
<p align="center">Fig.14 <a href="http://jalammar.github.io/illustrated-bert/">contextualize words embedding</a></p>

<h1 id="refernces">Refernces</h1>
<ul>
  <li><a href="https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html">Google AI Blog</a></li>
  <li><a href="https://arxiv.org/pdf/1810.04805.pdf">BERT: Pre-training of Deep Bidirectional Transformers for Language Understanding</a></li>
  <li><a href="https://arxiv.org/pdf/1706.03762.pdf">Attention Is All You Need</a></li>
  <li><a href="https://www.semanticscholar.org/paper/Conditional-BERT-Contextual-Augmentation-Wu-Lv/188024469a2443f262b3cbb5c5d4a96851949d68/figure/0">BERT Architecture</a></li>
  <li><a href="https://medium.com/@_init_/why-bert-has-3-embedding-layers-and-their-implementation-details-9c261108e28a">How the Embedding Layers in BERT Were Implemented</a></li>
  <li><a href="https://medium.com/@_init_/how-self-attention-with-relative-position-representations-works-28173b8c245a">How Self-Attention with Relative Position Representations works</a></li>
  <li><a href="https://leimao.github.io/blog/Byte-Pair-Encoding/">Byte Pair Encoding</a></li>
  <li><a href="http://jalammar.github.io/illustrated-bert/">The Illustrated BERT, ELMo, and co. (How NLP Cracked Transfer Learning)</a>
<!-- * <a href=""></a> --></li>
</ul>

:ET